"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.encryptLocalFile=exports.SIGNATURE_FILE_NAME=void 0;const tslib_1=require("tslib"),fs_1=tslib_1.__importDefault(require("fs")),log=tslib_1.__importStar(require("../../utils/log")),crypto_1=tslib_1.__importDefault(require("crypto"));async function encryptLocalFile(e,t){return new Promise((r,o)=>{let i={},l={};try{const e=require("tmp");e.setGracefulCleanup(),i=e.fileSync({mode:420,prefix:"",postfix:""}),l=e.fileSync({mode:420,prefix:"",postfix:""}),fs_1.default.closeSync(i.fd),fs_1.default.closeSync(l.fd)}catch(e){throw log.error("Error:",e),new Error("[encryptLocalFile failed] write compileresult to tmp file failed: "+e.message)}const n=fs_1.default.createReadStream(e),c=fs_1.default.createWriteStream(i.name);if(!t.crypt_key){const e="[encryptLocalFile failed] no crypt_key";return log.error(e),void o(e)}const a=crypto_1.default.randomBytes(12),s=crypto_1.default.createCipheriv("aes-256-gcm",Buffer.from(t.crypt_key,"base64"),a);n.pipe(s).pipe(c).on("finish",async()=>{try{const e=s.getAuthTag(),t=fs_1.default.statSync(i.name).size;log.info("nonce, nonce size: ",a,a.length),log.info("tag, tag size: ",e,null==e?void 0:e.length),log.info("encrypted file size in bytes: ",t);const n=Buffer.alloc(1);n.writeUInt8(e.length+a.length,0);const c=Buffer.concat([n,e,a]),f=await prependToFile(i.name,l.name,c);!0===f?r(l.name):(log.error("[encryptLocalFile failed] prependToFile",f),o(f))}catch(e){e.message="[encryptLocalFile failed] encryptLocalFile failed when finish: "+e.message,o(e)}}).on("error",e=>{o(e)})})}async function prependToFile(e,t,r){return new Promise(o=>{const i=fs_1.default.createReadStream(e),l=fs_1.default.createWriteStream(t);l.write(r),i.pipe(l),l.on("finish",()=>{o(!0)}),l.on("error",e=>{o(e)})})}exports.SIGNATURE_FILE_NAME="ci.signature",exports.encryptLocalFile=encryptLocalFile;